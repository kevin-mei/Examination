在平衡二叉树中，任意一个结点的左、右子树的髙度之差的绝对值不超过1。
虽然在结构上都符合二叉树的定义，但完全二叉树、线索二叉树、二叉排序树与最优二叉树的应用场合和概念都不同。
线索二叉树与二叉树的遍历运算相关，是一种存储结构。
二叉排序树的结构与给定的初始关键码序列相关。
最优二叉树(即哈夫曼树)是一类带权路径长度最短的二叉树，由给定的一个权值序列构造。
线索二叉树、二叉排序树和最优二叉树在结构上都不要求是平衡二叉树。
在完全二叉树中，去掉最后一层后就是满二叉树，而且最后一层上的叶子结点必须从该层的最左边开始排列，满足任意一个结点的左、右子树的高度之差的绝对值不超过1的条件，因此在形态上是一个平衡的二叉树。



**逆波兰式(reverse polish notation，也叫后缀表达式)**是将运算符写在操作数之后的表达式表示方法。对逆波兰式进行求值的方法是：从左至右扫描表达式，遇到操作数则压栈，遇到运算符号则从栈中弹出操作数进行运算，然后将运算结果压入栈中，重复该过程直到表达式结束，最后的结果为栈顶元素。由于控制上比较简单，所以逆波兰式更便于计算。
表达式“a-b+c*d”的后缀式为“ab-cd*+”。
表达式“(a-b)* c+d”的后缀式为“ab-c*d+”。
表达式“(a-b)* (c+d)”的后缀式为“ab-cd+*”。
表达式“a-b*c+d”的后缀式为“abc*-d+”。


**最优二叉树(即哈夫曼树):**
树的带权路径长度为树中所有叶子节点的带权路径长度之和。哈夫曼树是指权值为 w1，w2,…，wn的n个叶子节点的二叉树中带权路径长度最小的二叉树。
构造最优二叉树的哈夫曼算法如下：
(1)根据给定的n个权值{w1, w2,…，wn},构成n棵二叉树的集合F= {T1， T2,…，Tn}，其中每棵二叉树Ti中只有一个带权为wi的根节点，其左右子树均空。
在F中选取两棵权值最小的二叉树作为左、右子树构造一棵新的二叉树，置新 构造二叉树的根节点的权值为其左、右子树根节点的权值之和。
从F中删除这两棵树，同时将新得到的二叉树加入到F中。
重复(2)、(3)，直到F中只含一棵树时为止。这棵树便是最优二叉树(哈夫曼树)。 从以上叙述可知，**哈夫曼树中权值最小的两个节点互为兄弟节点。**

用N个全职构造一个最优二叉树，该二叉树的结点总数为2n-1


**前缀编码** 是指对字符集进行编码时，要求字符集中任一字符的编码都不是其它字符的编码的前缀，例如：设有abcd需要编码表示（其中，a=0、b=10、c=110、d=11,则表示110的前缀可以是c或者da，不唯一）

前缀编码构造方法
二叉树：约定左分支表示字符‘0’，右分支表示字符‘1’，则可以用从根结点到叶子结点的路径上的分支字符串作为该叶子结点字符的编码。如此得到的编码必是前缀编码。

·ABFACGCAHGBBAACECDFGFAAEABBB
1.统计：A(8) B(6) C(4) D(1) E(2) F(3) G(3)H(1)
2.构造Huffman树
3.得到Huffman编码
A： 01
B： 11
C： 001
D：00000
E： 0001
F： 100
G： 101
H：00001

每个节点对应的编码长度为： 出现次数*对应编码位数